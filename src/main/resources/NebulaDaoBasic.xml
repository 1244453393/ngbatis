<!--
    Copyright (c) 2022 All project authors and nebula-contrib. All rights reserved.

    This source code is licensed under Apache 2.0 License.
-->
<mapper namespace="org.nebula.contrib.ngbatis.proxy.NebulaDaoBasic">

    <select id="selectBySelective">
        @var kv = ng.kv( ng_args[0], '', false, true, false );
        @var tagName = ng.tagName( ng_args[0] );
        MATCH (n:`${ tagName }`)
        @if ( isNotEmpty( @kv.columns ) ) {
            WHERE
            @for ( col in @kv.columns ) {
                n.`${ tagName }`.${ col } == $${ @kv.valueNames.get( colLP.index - 1 ) }
                @if (!colLP.last) {
                    and
                @}
            @}
        @}
        RETURN n
        LIMIT 4000
    </select>

    <delete id="deleteWithEdgeById">
        DELETE VERTEX ${ ng.valueFmt( p0 ) } WITH EDGE
    </delete>

    <delete id="deleteById"></delete>

    <insert id="insert">
        @var kv = ng.kv( ng_args[0] );
        @var id = ng.id( ng_args[0] );
        @var tagName = ng.tagName( ng_args[0] );
        INSERT VERTEX `${ tagName }` (
            ${ ng.join( @kv.columns, ", ", "ng.schemaFmt" ) }
        )
        VALUES ${ id } : (
            ${ ng.join( @kv.values ) }
        );
    </insert>

    <insert id="insertSelective">
        @var kv = ng.kv( ng_args[0], '', true, true );
        @var id = ng.id( ng_args[0] );
        @var tagName = ng.tagName( ng_args[0] );
        INSERT VERTEX `${ tagName }` (
            ${ ng.join( @kv.columns, ", ", "ng.schemaFmt" ) }
        )
        VALUES ${ id } : (
            ${ ng.join( @kv.values ) }
        );
    </insert>

    <select id="selectById">
        match (n) where id(n) == $p0 return n
    </select>

    <select id="selectByIds"></select>

    <select id="selectBySelective"></select>

    <select id="selectBySelectivePrecise"/>
    <select id="selectByMap"/>
    <select id="countByMap"/>
    <select id="selectIdBySelective"/>
    <select id="updateByIdSelective"/>
    <select id="updateByIdWithBLOBs"/>
    <select id="updateById"/>
    <select id="insertBatch"/>
    <select id="countGridByMap"/>
    <select id="selectGridByMap"/>
    <select id="updateSelective"/>
    <select id="selectPage">
        @var query = @ng_args[0].entity;
        @var kv = ng.kv( query, 'entity', false, true, false );
        @var tag = ng.tagName( query, ng_cm );
        MATCH (n:${ tag })
        @if ( isNotEmpty( @kv.columns ) ) {
            WHERE
            @for ( col in @kv.columns ) {
                n.`${ tag }`.${ col } == $${ @kv.valueNames.get( colLP.index - 1 ) } ${ !colLP.last ? 'and' : '' }
            @}
        @}
        RETURN n skip $startRow limit $pageSize
    </select>

    <select id="countPage">
        @var query = @ng_args[0].entity;
        @var kv = ng.kv( query, 'entity', false, true, false );
        @var tag = ng.tagName( query, ng_cm );
        MATCH (n:${ tag })
        @if ( isNotEmpty( @kv.columns ) ) {
        WHERE
            @for ( col in @kv.columns ) {
                n.`${ tag }`.${ col } == $${ @kv.valueNames.get( colLP.index - 1 ) } ${ !colLP.last ? 'and' : '' }
            @}
        @}
        RETURN count(n)
    </select>

    <select id="updateBatch"/>

    <insert id="insertEdge">
        @var kv = ng.kv( ng_args[1], '', null, null, false );
        @var vId1 = ng.id( ng_args[0] );
        @var rank = ng.id( ng_args[1], false );
        @var vId2 = ng.id( ng_args[2] );
        @var e = ng.tagName( ng_args[1] );
        INSERT EDGE `${ e }` (
            ${ ng.join( @kv.columns, ", ", "ng.schemaFmt" ) }
        )
        VALUES ${ vId1 }-> ${ vId2 } ${ isNotEmpty( rank ) ? ('@' + rank) : ''  } :(
            ${ ng.join( @kv.values ) }
        );
    </insert>

    <select id="existsEdge">
        MATCH (n)-[r: ${ p1 }]-(n2)
        WHERE id(n) == $p0 AND id(n2) == $p2
        RETURN count(*) > 0
    </select>

    <select id="listStartNodes">
        MATCH (n: `${ p0 }`)-[r: `${ p1 }`]->(n2)
        WHERE id(n2) == $p2
        RETURN n
    </select>

    <select id="startNode">
        MATCH (n: `${ p0 }`)-[r: `${ p1 }`]->(n2)
        WHERE id(n2) == $p2
        RETURN n
        LIMIT 1
    </select>

</mapper>